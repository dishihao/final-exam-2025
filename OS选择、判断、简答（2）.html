<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>操作系统期末考试试卷（Part 2 纯净版）</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com" rel="preconnect">
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0" rel="stylesheet">
    <style>
        body {
            background-color: #e5e7eb;
            font-family: 'Noto Serif SC', 'SimSun', serif;
            color: #1f2937;
            line-height: 1.6;
        }
        .paper {
            background-color: white;
            width: 100%;
            max-width: 210mm;
            min-height: 297mm;
            margin: 20px auto;
            padding: 20mm;
            padding-left: 30mm; /* 为密封线留出空间 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            position: relative;
            box-sizing: border-box;
        }
        
        /* 密封线 */
        .sealing-line {
            position: absolute;
            left: 12mm;
            top: 0;
            bottom: 0;
            border-right: 1px dashed #9ca3af;
            padding-right: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #6b7280;
            font-size: 0.9rem;
            user-select: none;
        }
        .sealing-line span {
            writing-mode: vertical-lr;
            letter-spacing: 2em;
            margin: 20px 0;
        }

        /* 红色楷体手写效果 */
        .red-pen {
            font-family: "KaiTi", "STKaiti", "楷体", serif;
            color: #c92a2a; 
            font-size: 1.15em;
            display: inline-block;
            margin-left: 0.3rem;
            font-weight: 500;
        }
        .red-pen-block {
            font-family: "KaiTi", "STKaiti", "楷体", serif;
            color: #c92a2a;
            font-size: 1.05em;
            margin-top: 0.5rem;
            padding: 1rem;
            border-left: 4px solid #fecaca;
            background-color: #fff5f5;
            border-radius: 4px;
            line-height: 1.8;
        }
        
        /* 题目布局 */
        .q-item {
            display: flex;
            align-items: baseline;
            margin-bottom: 0.5rem;
        }
        .q-num {
            min-width: 1.5em;
            font-weight: bold;
            margin-right: 0.5rem;
        }
        
        /* 选项网格 */
        .grid-options {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            margin-left: 2rem;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
            color: #4b5563;
        }
        .grid-options-2 {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin-left: 2rem;
            margin-bottom: 0.5rem;
            font-size: 0.95rem;
            color: #4b5563;
        }
        
        /* 选对的选项高亮 */
        .option-correct {
            color: #1f2937;
            font-weight: bold;
            position: relative;
        }
        .tick-mark {
            font-family: "KaiTi", serif;
            color: #c92a2a;
            position: absolute;
            left: -1.2em;
            top: -0.2em;
            font-size: 1.4em;
            font-weight: bold;
        }

        /* 解析文字 */
        .analysis {
            margin-left: 2rem;
            margin-bottom: 1.5rem;
            font-family: "KaiTi", "STKaiti", "楷体", serif;
            color: #b91c1c;
            font-size: 0.9rem;
            background-color: #fff1f2;
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
        }

        @media print {
            body { background: none; }
            .paper { margin: 0; box-shadow: none; width: 100%; padding: 20mm; }
        }
    </style>
</head>
<body>

<div class="paper">
    <!-- 密封线 -->
    <div class="sealing-line">
        <span>装</span>
        <span>订</span>
        <span>线</span>
    </div>

    <!-- 试卷抬头 -->
    <div class="text-center border-b-2 border-gray-800 pb-6 mb-8">
        <h1 class="text-3xl font-bold mb-6 tracking-widest">操作系统原理 考试试卷 (二)</h1>
        <div class="flex justify-center gap-12 text-sm font-serif text-gray-700">
            
            
            
        </div>
    </div>

    <!-- 一、选择题 -->
    <div class="mb-8">
        <h2 class="text-lg font-bold mb-4 border-l-4 border-gray-800 pl-3">一、选择题</h2>
        
        <!-- Q1 -->
        <div class="q-item">
            <span class="q-num">1.</span>
            <p>批处理系统中，衡量作业运行效率的核心指标“周转时间”是指（ <span class="red-pen"> B </span> ）。</p>
        </div>
        <div class="grid-options-2">
            <label>A. 作业从提交到运行完毕的总时间</label>
            <label class="option-correct"><span class="tick-mark">√</span>B. 作业从提交到完成的总时间</label>
            <label>C. 作业在内存中等待调度的时间</label>
            <label>D. 作业实际占用 CPU 的运行时间</label>
        </div>
        <div class="mb-4"></div>

        <!-- Q2 -->
        <div class="q-item">
            <span class="q-num">2.</span>
            <p>分时系统中，若用户数目为 40，要求响应时间不超过 800ms，则时间片最大应为（ <span class="red-pen"> B </span> ）。</p>
        </div>
        <div class="grid-options">
            <label>A. 10ms</label>
            <label class="option-correct"><span class="tick-mark">√</span>B. 20ms</label>
            <label>C. 30ms</label>
            <label>D. 40ms</label>
        </div>
        <div class="analysis">
            解析：时间片 Q = 响应时间 T / 用户数 N = 800ms / 40 = 20ms。
        </div>

        <!-- Q3 -->
        <div class="q-item">
            <span class="q-num">3.</span>
            <p>进程 A 需等待进程 B 发送数据后才能继续执行，这种因协作需求产生的进程制约关系称为（ <span class="red-pen"> A </span> ）。</p>
        </div>
        <div class="grid-options">
            <label class="option-correct"><span class="tick-mark">√</span>A. 同步</label>
            <label>B. 互斥</label>
            <label>C. 调度</label>
            <label>D. 中断</label>
        </div>
        <div class="mb-4"></div>

        <!-- Q4 -->
        <div class="q-item">
            <span class="q-num">4.</span>
            <p>PV 操作中，信号量的初始值为 3，连续执行 4 次 P 操作后，信号量的值及进程状态为（ <span class="red-pen"> A </span> ）。</p>
        </div>
        <div class="grid-options-2">
            <label class="option-correct"><span class="tick-mark">√</span>A. -1，当前进程阻塞</label>
            <label>B. 0，当前进程继续执行</label>
            <label>C. -1，当前进程就绪</label>
            <label>D. 0，所有进程阻塞</label>
        </div>
        <div class="analysis">
            解析：信号量 S = 3 - 4 = -1。当 S < 0 时，|S| 表示阻塞队列中的进程数，当前执行 P 操作的进程会被阻塞。
        </div>

        <!-- Q5 -->
        <div class="q-item">
            <span class="q-num">5.</span>
            <p>死锁避免策略的核心机制是（ <span class="red-pen"> A </span> ）。</p>
        </div>
        <div class="grid-options-2">
            <label class="option-correct"><span class="tick-mark">√</span>A. 确保资源分配后系统处于安全状态</label>
            <label>B. 破坏死锁的互斥条件</label>
            <label>C. 限制进程的最大资源需求量</label>
            <label>D. 定期回收进程占用的资源</label>
        </div>
        <div class="mb-4"></div>

        <!-- Q6 -->
        <div class="q-item">
            <span class="q-num">6.</span>
            <p>某进程访问页面的序列为 1,4,1,5,2,5,3,5,2，物理内存块数为 2，采用 FIFO 算法的缺页次数为（ <span class="red-pen"> D </span> ）。</p>
        </div>
        <div class="grid-options">
            <label>A. 4 次</label>
            <label>B. 5 次</label>
            <label>C. 6 次</label>
            <label class="option-correct"><span class="tick-mark">√</span>D. 7 次</label>
        </div>
        <div class="analysis">
            解析：页面走向：1(缺), 4(缺), 1(中), 5(缺,换1), 2(缺,换4), 5(中), 3(缺,换5), 5(缺,换2), 2(缺,换3)。共7次缺页。
        </div>

        <!-- Q7 -->
        <div class="q-item">
            <span class="q-num">7.</span>
            <p>分页存储管理中，页大小为 4KB (2<sup>12</sup>B)，逻辑地址为 20 位，则页号占（ <span class="red-pen"> B </span> ）位。</p>
        </div>
        <div class="grid-options">
            <label>A. 6</label>
            <label class="option-correct"><span class="tick-mark">√</span>B. 8</label>
            <label>C. 10</label>
            <label>D. 12</label>
        </div>
        <div class="analysis">
            解析：逻辑地址长度 = 页号长度 + 页内偏移。页大小 4KB = 2<sup>12</sup>，故页内偏移 12 位。页号 = 20 - 12 = 8 位。
        </div>

        <!-- Q8 -->
        <div class="q-item">
            <span class="q-num">8.</span>
            <p>某段表内容如下，逻辑地址 [2, 1800] (单位：字节) 对应的物理地址为（ <span class="red-pen"> A </span> ）。<br><span class="text-xs text-gray-500 ml-6">（注：段2 基址600K, 长度20K）</span></p>
        </div>
        <div class="grid-options-2">
            <label class="option-correct"><span class="tick-mark">√</span>A. 600K + 1800</label>
            <label>B. 20K + 1800</label>
            <label>C. 2 + 600K</label>
            <label>D. 1800 + 20K</label>
        </div>
        <div class="analysis">
            解析：物理地址 = 段基址 + 段内偏移。检查偏移 1800 < 段长 20K，合法。故地址 = 600K + 1800。
        </div>
    </div>

    <!-- 二、判断题 -->
    <div class="mb-8">
        <h2 class="text-lg font-bold mb-4 border-l-4 border-gray-800 pl-3">二、判断题</h2>
        <div class="space-y-3 text-sm">
            <div class="q-item">
                ( <span class="red-pen font-bold"> √ </span> ) 1. 并行性是“多个事件同时刻发生”，并发性是“多个事件同一时间间隔发生”，二者本质不同。
            </div>
            <div class="q-item">
                ( <span class="red-pen font-bold"> × </span> ) 2. 单 CPU 系统中，进程的“阻塞状态”可直接转换为“运行状态”，无需经过就绪队列。
            </div>
            <div class="q-item">
                ( <span class="red-pen font-bold"> √ </span> ) 3. 静态优先级在进程创建时确定，动态优先级会根据进程等待时间、CPU 占用率等动态调整。
            </div>
            <div class="q-item">
                ( <span class="red-pen font-bold"> √ </span> ) 4. 缺页中断属于内中断，其处理过程需涉及页面置换与地址重定位。
            </div>
            <div class="q-item">
                ( <span class="red-pen font-bold"> × </span> ) 5. 资源分配图中存在环就一定发生死锁，无环则一定无死锁。（注：单实例资源下环=死锁，多实例不一定）
            </div>
            <div class="q-item">
                ( <span class="red-pen font-bold"> √ </span> ) 6. 段页式存储管理先分段再分页，既保持了逻辑独立性，又提高了内存利用率。
            </div>
            <div class="q-item">
                ( <span class="red-pen font-bold"> √ </span> ) 7. 分页存储中页面共享需通过共享页表项实现，分段存储中段共享可直接通过段表项指向同一物理段。
            </div>
            <div class="q-item">
                ( <span class="red-pen font-bold"> × </span> ) 10. 快表 (TLB) 的命中率越高，逻辑地址到物理地址的转换效率越低。（注：应为越高）
            </div>
        </div>
    </div>

    <!-- 三、简答题 -->
    <div class="mb-8">
        <h2 class="text-lg font-bold mb-4 border-l-4 border-gray-800 pl-3">三、简答题</h2>
        
        <div class="mb-6">
            <p class="font-bold mb-2">1. 什么是死锁? 简述死锁的四个必要条件，并说明如何通过破坏其中一个条件来预防死锁。</p>
            <div class="red-pen-block">
                <p>答：</p>
                <p><strong>死锁：</strong> 多个进程因竞争资源而造成的一种互相等待的僵局，无外力作用下无法继续推进。</p>
                <p><strong>四个必要条件：</strong></p>
                <ol class="list-decimal list-inside pl-2">
                    <li>互斥条件</li>
                    <li>请求与保持条件</li>
                    <li>不可剥夺条件</li>
                    <li>循环等待条件</li>
                </ol>
                <p><strong>预防示例：</strong> 破坏“请求与保持”条件：要求进程在运行前一次性申请所有所需资源，若满足则分配，否则等待。</p>
            </div>
        </div>

        <div class="mb-6">
            <p class="font-bold mb-2">2. 请简述分页存储管理和分段存储管理的主要区别。</p>
            <div class="red-pen-block">
                <p>答：</p>
                <ol class="list-decimal list-inside pl-2">
                    <li><strong>单位不同：</strong> 页是信息的物理单位，大小固定；段是信息的逻辑单位，大小不固定。</li>
                    <li><strong>地址维度：</strong> 分页是一维地址空间；分段是二维地址空间（段号 + 段内偏移）。</li>
                    <li><strong>碎片情况：</strong> 分页产生内部碎片（页内碎片）；分段产生外部碎片。</li>
                    <li><strong>目的不同：</strong> 分页是为了提高内存利用率；分段是为了满足用户逻辑需求（如共享、保护）。</li>
                </ol>
            </div>
        </div>
    </div>

</div>

<script>
    function exportHTML() {
        const htmlContent = document.documentElement.outerHTML;
        const blob = new Blob([htmlContent], {type: 'text/html'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'OS_Exam_Part2_Pure.html';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
</script>

</body>
</html>
